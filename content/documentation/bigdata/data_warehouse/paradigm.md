---
title: 3.1. 范式
weight: 1
#next: /step1
prev: /data_warehouse
editURL: "https://example.com/edit/this/page"
type: "docs" # 点击后任然显示左边目录
toc: true
math: true
---

## 1. 什么是范式？

{{< callout >}}
  王珊的《数据库系统概论》中的定义，范式是“***符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度***”。<br>简单说就是 ***数据表结构符合某种设计标准的级别***。
{{< /callout >}}


<br><br>


## 2. 范式特点

1. 范式级别越高，表设计越标准、规范化；（数据冗余更少；数据一致性更强；依赖关系更合理）
2. 高级别范式必定符合低级别范式要求(如符合2NF必定符合1NF)；
3. 常见范式有1NF、2NF、3NF、BCNF、4NF、5NF；

> - 零范式：***数据中不存在重复数据***；
> - 一范式：在零范式的基础上，加上关系中的 ***每个属性（字段）都不可再分（原子性）***；
    
    
<br><br>


## 3. 常见范式

### 3.1. 零范式

{{< callout >}}
  零范式：***数据中不存在重复数据***。
{{< /callout >}}

| 学生成绩记录                     |
|----------------------------------|
| 1001,张三,CS101,90              |
| 1002,李四,MATH202,85            |
| 1003,王五,PHYS101,92            |
| 1004,赵六,CHEM304,88            |



<br>



### 3.2. 一范式

{{< callout >}}
  一范式：在零范式的基础上，加上关系中的***每个属性（字段）都不可再分（原子性）***<br>
{{< /callout >}}

- 在零范式的基础上 ***加上关系中的每个属性（字段）都不可再分（原子性）*** 这个条件后便形成了符合一范式的表。<br>
- ***1NF是所有关系型数据库的最基本要求***。

| 学号 | 姓名 | 课程编号 | 课程名称 | 成绩 | 教师 | 教师职称 |
|------|------|----------|----------|------|------|------|
| 1001 | 张三 | CS101    | 数据库   | 90   | 王老师 |教授     |
| 1001 | 张三 | MATH202  | 高等数学 | 85   | 李老师 |教授     |
| 1002 | 李四 | CS101    | 数据库   | 88   | 王老师 |教授     |
| 1002 | 李四 | CS102    | python   | 98   | 张老师 |副教授     |

***一范式（1NP）存在的问题：***

1. ***数据冗余***：相同信息在多个行中重复存储，特别是当存在部分依赖时。如，学生姓名、课程名称和教师信息被重复存储；
2. ***更新异常***：修改一处信息需要更新多处，容易造成数据不一致。如，如果"数据库"课程改名为"数据库系统"，需要更新所有相关行；
3. ***插入异常***：无法单独插入某些信息，必须依赖主键完整信息。如，无法单独添加一个新课程（没有学生选修时）；
4. ***删除异常***：删除某些信息会导致连带删除有用信息。如，删除最后一个选修某课程的学生记录会连带删除该课程信息；
5. ***空间浪费***：固定长度字段可能浪费空间，变长字段管理开销大；

{{< callout type="info">}}
1NF虽然消除了0NF的非原子值问题，但仍需进一步规范化以减少数据冗余和维护异常。
{{< /callout >}}



<br>



### 3.3. 二范式

{{< callout >}}
  二范式：在 1NF 基础上，***消除了非主属性对码的部分依赖***。<br>
  ***确保每一列都和主键完全相关，而不能只与主键的某一部分相关。二范式的判断方法：***
{{< /callout >}}

***第一步：找出数据表中所有的码***

  - ***码的定义：能唯一标识一行数据的最小属性组合***
  - 判断方法：找出所有可能的属性组合，检查是否能唯一确定其他所有属性。
  - 确保该组合中没有冗余属性（即去掉任意一个属性就不能唯一标识）。

  - 示例（原始表）：

  | 学号 | 姓名 | 课程编号 | 课程名称 | 成绩 | 教师 | 教师职称 |
|------|------|----------|----------|------|------|------|
| 1001 | 张三 | CS101    | 数据库   | 90   | 王老师 |教授     |
| 1001 | 张三 | MATH202  | 高等数学 | 85   | 李老师 |教授     |
| 1002 | 李四 | CS101    | 数据库   | 88   | 王老师 |教授     |
| 1002 | 李四 | CS102    | python   | 98   | 张老师 |副教授     |

  - 可能的码：
    - ***(学号, 课程编号)*** 能唯一确定成绩（一个学生的一门课程只有一个成绩）。
    - 其他组合（如单独学号、单独课程编号）无法唯一标识整行数据。

<br>

***第二步：确定所有主属性***

  - 示例：

    - 码：(学号, 课程编号)
    - 主属性：学号、课程编号（***主属性：所有属于任何一个码的属性***）
    - 非主属性：姓名、课程名称、成绩、教师（***不属于任何码的属性***）

<br>

***第三步：检查非主属性是否存在对码的部分函数依赖***（非主属性仅依赖于码的部分属性）

  - 依赖关系分析：
    - 成绩：由 (学号, 课程编号) 共同决定 → 完全依赖（符合2NF）。
    - 姓名：仅由 学号 决定（与课程编号无关）→ 部分依赖（违反2NF）。
    - 课程名称 和 教师：仅由 课程编号 决定（与学号无关）→ 部分依赖（违反2NF）。


<br>

***第四步：结论***

  - 示例表违反 2NF 的字段：姓名、课程名称、教师（均部分依赖于码）。
  - 解决方法：
    - 将表拆分为三个表，确保非主属性完全依赖于码：
    - 学生表（主键：学号）：存储 姓名。
    - 课程表（主键：课程编号）：存储 课程名称 和 教师。
    - 选课表（主键：(学号, 课程编号)）：存储 成绩。

<div style="display: flex; justify-content: center; width: 100%;">
  <div style="flex: 17%; padding: 10px; box-sizing: border-box; text-align: center;"> 

| 学号 | 姓名 |
|------|------|
| 1001 | 张三 |
| 1002 | 李四 |

  </div>

  <div style="flex: 40%; padding: 10px; box-sizing: border-box; text-align: center;">

| 课程编号 | 课程名称 | 教师 | 教师职称 |
|----------|----------|------|----------|
| CS101    | 数据库   | 王老师 | 教授     |
| MATH202  | 高等数学 | 李老师 | 教授     |
| CS102    | Python   | 张老师 | 副教授   |

  </div>

  <div style="flex: 30%; padding: 10px; box-sizing: border-box; text-align: center;">

| 学号 | 课程编号 | 成绩 |
|------|----------|------|
| 1001 | CS101    | 90   |
| 1001 | MATH202  | 85   |
| 1002 | CS101    | 88   |
| 1002 | CS102    | 98   |

  </div>

  <div style="flex: 20%; padding: 10px; box-sizing: border-box; text-align: center;"></div>
</div>


- 满足2NF：
  - 消除了原始表的"部分依赖"（如学生姓名仅依赖学号）
  - 所有非主属性完全依赖于各自表的主键



<br>

### 3.4. 三范式

{{< callout >}}
  在二范式（2NF）的基础上进一步 ***消除传递函数依赖***。<br>
{{< /callout >}}

- 将以下下满足 2NF 不满足 3NF 的三张表修改为满足 3NF 的结果：

<div style="display: flex; justify-content: center; width: 100%;">
  <div style="flex: 17%; padding: 10px; box-sizing: border-box; text-align: center;"> 

| 学号 | 姓名 |
|------|------|
| 1001 | 张三 |
| 1002 | 李四 |

  </div>

  <div style="flex: 40%; padding: 10px; box-sizing: border-box; text-align: center;">

| 课程编号 | 课程名称 | 教师 | 教师职称 |
|----------|----------|------|----------|
| CS101    | 数据库   | 王老师 | 教授     |
| MATH202  | 高等数学 | 李老师 | 教授     |
| CS102    | Python   | 张老师 | 副教授   |

  </div>

  <div style="flex: 30%; padding: 10px; box-sizing: border-box; text-align: center;">

| 学号 | 课程编号 | 成绩 |
|------|----------|------|
| 1001 | CS101    | 90   |
| 1001 | MATH202  | 85   |
| 1002 | CS101    | 88   |
| 1002 | CS102    | 98   |

  </div>

  <div style="flex: 20%; padding: 10px; box-sizing: border-box; text-align: center;"></div>
</div>


- 上面课程表中教师职称对课程编号存在传递依赖：
  - 课程编号 → 教师
  - 教师 → 教师职称
  - 因此 ***课程编号 → 教师职称是传递依赖***

<br>

- ***存在问题：***
  1. ***数据冗余***：同一教师的职称重复存储（如王老师的"教授"职称）
  2. ***更新异常***：若王老师晋升为"特聘教授"，需更新所有相关课程记录
  3. ***插入异常***：无法单独添加教师信息（必须关联课程）
  4. ***删除异常***：删除某教师的最后一门课程会丢失其职称信息


<br>

- ***拆分课程表为：课程表（仅保留直接依赖） + 教师表。最终 3NF表结构如下：***

<div style="display: flex; justify-content: center; width: 100%;">
  <div style="flex: 30%; padding: 10px; box-sizing: border-box; text-align: center;"> 

| 课程编号 | 课程名称 | 教师工号 |
|----------|----------|----------|
| CS101    | 数据库   | T001     |
| MATH202  | 高等数学 | T002     |
| CS102    | Python   | T003     |
  </div>

  <div style="flex: 30%; padding: 10px; box-sizing: border-box; text-align: center;">

| 教师工号 | 教师姓名 | 教师职称 |
|----------|----------|----------|
| T001     | 王老师   | 教授     |
| T002     | 李老师   | 教授     |
| T003     | 张老师   | 副教授   |

  </div>

  <div style="flex: 40%; padding: 10px; box-sizing: border-box; text-align: center;"></div>
</div>



<div style="display: flex; justify-content: center; width: 100%;">
  <div style="flex: 30%; padding: 10px; box-sizing: border-box; text-align: center;">

| 教师工号 | 教师姓名 | 教师职称 |
|----------|----------|----------|
| T001     | 王老师   | 教授     |
| T002     | 李老师   | 教授     |
| T003     | 张老师   | 副教授   |

  </div>

  <div style="flex: 30%; padding: 10px; box-sizing: border-box; text-align: center;">

| 学号 | 课程编号 | 成绩 |
|------|----------|------|
| 1001 | CS101    | 90   |
| 1001 | MATH202  | 85   |
| 1002 | CS101    | 88   |
| 1002 | CS102    | 98   |
  
  </div>

  <div style="flex: 40%; padding: 10px; box-sizing: border-box; text-align: center;"></div>
</div>


- ***改进说明：***

| 问题类型   | 2NF结构问题                 | 3NF解决方案                |
|------------|-----------------------------|---------------------------|
| 数据冗余   | 教师职称重复存储（如"教授"） | 教师职称只在教师表存储一次 |
| 更新异常   | 修改职称需更新多门课程       | 只需更新教师表的一行       |
| 插入异常   | 必须通过课程添加教师         | 可独立维护教师信息         |
| 删除异常   | 删除课程可能丢失教师信息     | 教师信息独立存在           |


<br>


### 3.5. BCNF 范式


{{< callout >}}
  BCNF（巴斯-科德范式） 是比 3NF 更严格的数据库规范化形式，旨在 ***进一步消除数据冗余和操作异常***。<br>它的核心要求是：如果 $X→Y$ 成立，则 $X$ 必须是 候选键或超键（唯一标识 关系中元组的 属性集）<br> ***BCNF要求：所有“决定因素”必须是超键（即能唯一标识一行的属性集，可能包含冗余属性）***

  “ 如果一个属性（比如学院）是由另一个属性（比如老师工号）决定的，那么这个‘决定者’（老师工号）必须是表的唯一标识。”
{{< /callout >}}

初始表如下（满足 3NF，但违反 BCNF）

| 研究生ID | 导师ID | 院系   |
|----------|--------|--------|
| S001     | T01    | 计算机系 |
| S002     | T02    | 数学系   |
| S003     | T01    | 计算机系 |

- ***函数依赖：***
  - 研究生ID → 导师ID, 院系（主键依赖）
  - 导师ID → 院系（非超键决定因素）

- ***问题：***
  - 导师ID → 院系，但 导师ID 不是超键（主键是 研究生ID），违反 BCNF。
  - 数据冗余：同一个导师的院系信息会重复存储。
  - 更新异常：如果导师 T01 从计算机系转到信息学院，需要修改所有相关行。
  - 插入异常：如果新入职一位导师 T04 在物理系，但尚未分配研究生，则无法直接插入该导师的院系信息。
  - 删除异常：如果删除某个导师的最后一个研究生，会意外丢失该导师的院系信息。

<br>

- ***BCNF 分解：***

<div style="display: flex; justify-content: center; width: 100%;">
  <div style="flex: 20%; padding: 10px; box-sizing: border-box; text-align: center;">

| 导师ID | 院系   |
|--------|--------|
| T01    | 计算机系 |
| T02    | 数学系   |

  </div>

  <div style="flex: 20%; padding: 10px; box-sizing: border-box; text-align: center;">

| 研究生ID | 导师ID |
|----------|--------|
| S001     | T01    |
| S002     | T02    |
| S003     | T01    |

  </div>

  <div style="flex: 60%; padding: 10px; box-sizing: border-box; text-align: center;"></div>
</div>

- ***改进后：***
  - 所有函数依赖的决定因素（导师ID、研究生ID）都是超键，符合 BCNF。


<br>


{{< callout >}}
 ***BCNF 的终极目标：让所有“决定者”当主键！***
{{< /callout >}}



<br><br>



## 补充知识

### 1. 函数依赖：

在一张表中，在属性（或属性组） $X$ 的值确定的情况下，必定能确定属性 $Y$ 的值，那么就可以说 $Y$ 函数依赖于 $X$ ，写作。类似于函数关系 $y=f(x)$ ，在 $x$ 的值确定的情况下， $y$ 的值一定是确定的。

1. 学号 → 姓名
2. 系名 → 系主任
3. （学号，课名） → 分数

<br>



### 2. 完全函数依赖：

在一张表中，若 $X → Y$，且对于 $X$ 的任何一个真子集（假如属性组 $X$ 包含超过一个属性的话），$X ' →  Y$ 不成立，那么我们称 $Y$  对于 $X$ 完全函数依赖，记作 $X$。

1. 学号 姓名
2. （学号，课名）→ 分数

<br>



### 3. 传递函数依赖：

假如 $Z$ 函数依赖于 $Y$，且 $Y$ 函数依赖于 $X$ （严格来说还有一个 $X$ 不包含于 $Y$，且 $Y$ 不函数依赖于 $Z$ 的前提条件），那么我们就称 $Z$ 传递函数依赖于 $X$ ，记作 $X → Z$。

1. 课程编号 → 教师工号 → 教师职称，最终传递依赖：课程编号 → 教师职称

<br>



### 4. 码（候选码）

#### 4.1. ***码的定义***：

在关系数据库（表）中，码是指能够唯一标识表中每一行（元组） 的一个属性（字段）或一组属性的组合。<br>
换句话说，码的作用是确保表中的每一条记录都是唯一可区分的。

<br>

#### 4.2. ***码的特性***：

唯一性（Uniqueness）：码的值必须能够唯一确定一行，即表中不能存在两个不同的行在码上的取值完全相同。<br>
***最小性（Minimality）***：码的组成属性是最小的，即不能从码中移除任何一个属性而仍然保持唯一性。<br>（例如，如果 (学号, 姓名) 能唯一标识一行，但 学号 本身就能唯一标识，那么 (学号, 姓名) 就不是最小码，学号 才是。）

<br>

#### 4.3. ***码的判断方法***：

设 $K$ 是表中的一个属性或属性组，若满足：<br>
完全函数依赖：表中所有其他属性都完全函数依赖于 $K$（即所有非码属性必须由整个 $K$ 决定，而不是 $K$ 的一部分）。<br>
唯一标识：$K$ 的值一旦确定，整行的其他属性值也随之唯一确定。<br>
则 $K$ 是一个候选码（码）。

<br>

#### 4.4. ***码的示例***：

{{< tabs items="1️⃣ 学生表, 2️⃣ 选课表" >}}

  {{< tab >}}

| 学号 | 姓名 | 年龄 | 系别   |
|------|------|------|--------|
| 1001 | 张三 | 20   | 计算机 |
| 1002 | 李四 | 21   | 数学   |

***可能的码：***
  - 学号：可以唯一确定一行（没有重复学号）。
  - 姓名：如果姓名不重复（比如没有两个“张三”），则 姓名 也可以是码（但现实中可能有重名，所以通常 学号 更合适）。

***结论：***
  - 学号 是码（候选码）。
  - 如果姓名不重复，姓名 也可以是另一个码（但通常不这么做）。
  {{< /tab >}}


  {{< tab >}}
| 学号 | 课程编号 | 成绩 | 教师   |
|------|----------|------|--------|
| 1001 | CS101    | 90   | 王老师 |
| 1001 | MATH202  | 85   | 李老师 |
| 1002 | CS101    | 88   | 王老师 |

***可能的码：***
  - (学号, 课程编号)：因为一个学生的一门课程只有一个成绩，这个组合可以唯一标识一行。
  - 单独 学号 或 课程编号 不能唯一标识一行（因为一个学生可以选多门课，一门课可以被多个学生选）。

***结论：***
  - (学号, 课程编号) 是唯一的码（复合码）。

  {{< /tab >}}

{{< /tabs >}}


<br>


####  4.5. ***码 vs. 主码***

- 码（候选码）：所有可能的唯一标识属性（组）。
- 主码（Primary Key）：从候选码中选一个作为主要标识符（通常选最短、最稳定的）<br>

<br>

- 例如，在学生表中，学号 和 身份证号 可能都是码，但通常选择 学号 作为主码。
  - 候选码：学号、身份证号（都能唯一标识一行）。
  - 主码：通常选择 学号（更短，更常用）。
  
  | 学号 | 身份证号   | 姓名 | 年龄 |
|------|------------|------|------|
| 1001 | 110101... | 张三 | 20   |
| 1002 | 110102... | 李四 | 21   |




<br>


#### 4.6. ***总结***

- 码的作用是唯一标识一行。
- 一个表可以有多个码，但通常只选一个作为主码。
- 主码通常是最短、最稳定的候选码（如 学号 比 (姓名, 出生日期) 更优）。<br>

  | 概念         | 解释                                                                 |
|--------------|----------------------------------------------------------------------|
| 码（候选码） | 能唯一标识一行的一个或一组属性，且不能去掉其中任何一个属性仍保持唯一。 |
| 主码         | 从候选码中选择的一个主要标识符（通常是最短、最稳定的）。              |
| 完全函数依赖 | 所有非码属性必须由整个码决定，不能仅依赖码的一部分（否则违反2NF）。   |





<br><br>

## 参考网址：

1. [数据库第一二三范式到底在说什么？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/20028672)
2. [(99+ 封私信 / 80 条消息) 如何通俗理解第一、二、三「范式」？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/34953197/answer/1204203974)
3. [第六章 关系数据理论 范式-CSDN博客](https://blog.csdn.net/csdn_blog_lcl/article/details/78585252)
4. [01-数据仓库之数据建模 - 李昊宗 - 博客园 (cnblogs.com)](https://www.cnblogs.com/lihaozong2013/p/10725830.html)

